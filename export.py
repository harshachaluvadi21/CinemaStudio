"""
export.py — TXT, PDF, and DOCX export helpers for Coffee-with-Cinema.

Each function accepts a content string and a section name, and returns a
BytesIO object ready to be served via Flask's send_file().
"""

import io
import logging
from reportlab.lib.pagesizes import LETTER
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, HRFlowable, PageBreak
from reportlab.lib.enums import TA_LEFT, TA_CENTER
from docx import Document
from docx.shared import Pt, RGBColor, Inches

logger = logging.getLogger(__name__)

SECTION_TITLES = {
    "screenplay": "Screenplay",
    "characters": "Character Profiles",
    "sound": "Sound Design Notes",
}


# ─── TXT ──────────────────────────────────────────────────────────────────────

def to_txt(content: str, section: str) -> io.BytesIO:
    """
    Wrap content in a plain-text file with a title header.

    Args:
        content: The generated text for this section.
        section: One of 'screenplay', 'characters', 'sound'.

    Returns:
        BytesIO containing UTF-8 encoded text.
    """
    title = SECTION_TITLES.get(section, section.title())
    header = f"CINEMA STUDIO\n{'=' * 40}\n{title.upper()}\n{'=' * 40}\n\n"
    buf = io.BytesIO()
    buf.write((header + content).encode("utf-8"))
    buf.seek(0)
    return buf


# ─── PDF ──────────────────────────────────────────────────────────────────────

def to_pdf(content: str, section: str, username: str = "User") -> io.BytesIO:
    """
    Generate a styled PDF using ReportLab.

    Args:
        content: The generated text for this section.
        section: One of 'screenplay', 'characters', 'sound'.
        username: The name of the user to display on the title page.

    Returns:
        BytesIO containing PDF bytes.
    """
    # Standard Hollywood margins: Left 1.5", Right 1.0", Top/Bottom 1.0"
    buf = io.BytesIO()
    doc = SimpleDocTemplate(
        buf,
        pagesize=LETTER,
        leftMargin=1.5 * inch,
        rightMargin=1.0 * inch,
        topMargin=1.0 * inch,
        bottomMargin=1.0 * inch,
    )

    styles = getSampleStyleSheet()
    
    # Custom Screenplay Styles
    style_normal = ParagraphStyle(
        "ScreenplayNormal",
        parent=styles["Normal"],
        fontName="Courier",
        fontSize=12,
        leading=12,  # Single spacing (12pt leading for 12pt font is tight, standard is usually 12pt font on 12pt line? Actually usually loose. Let's stick to simple.) 
        # Actually standard is 6 lines per inch -> 12pt leading.
        spaceAfter=0,
        alignment=TA_LEFT,
        textColor=colors.black,
    )

    style_slugline = ParagraphStyle(
        "ScreenplaySlug",
        parent=style_normal,
        fontName="Courier-Bold",
        spaceBefore=12,
        spaceAfter=12,
        keepWithNext=True,
    )

    style_character = ParagraphStyle(
        "ScreenplayChar",
        parent=style_normal,
        fontName="Courier-Bold", # Bold as requested
        leftIndent=2.0 * inch,
        spaceBefore=12,
        keepWithNext=True,
    )

    style_dialogue = ParagraphStyle(
        "ScreenplayDialogue",
        parent=style_normal,
        leftIndent=1.0 * inch, # Dialogue starts at ~2.5" from left edge.
        rightIndent=1.0 * inch, # Wraps at ~6.0" from left edge.
    )

    style_parenthetical = ParagraphStyle(
        "ScreenplayParen",
        parent=style_normal,
        leftIndent=1.6 * inch,
        keepWithNext=True,
    )

    # Title Page
    title_style = ParagraphStyle(
        "TitlePageTitle",
        parent=styles["Normal"],
        fontName="Courier-Bold",
        fontSize=24,
        alignment=TA_CENTER,
        spaceBefore=3 * inch,
        spaceAfter=0.5 * inch,
    )
    
    subtitle_style = ParagraphStyle(
        "TitlePageSub",
        parent=styles["Normal"],
        fontName="Courier",
        fontSize=12,
        alignment=TA_CENTER,
    )

    # Content Building
    story = []

    # Simple Title Page if it's the screenplay section
    if section == "screenplay":
        story.append(Paragraph("CINEMA STUDIO PROJECT", title_style))
        story.append(Paragraph(SECTION_TITLES.get(section, ""), subtitle_style))
        story.append(Paragraph(f"Screenplay by {username}", subtitle_style))
        story.append(Paragraph("Generated by Granite4 Micro", subtitle_style))
        story.append(PageBreak())

    # Helper to process Markdown-like formatting (bold)
    def format_markdown(text):
        # bold **text** -> <b>text</b>
        # We need to be careful not to break XML. ReportLab supports extremely simple tags.
        # It's safer to just do simple replacements for now.
        processed = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        
        # Bold: **...**
        if "**" in processed:
             parts = processed.split("**")
             # Reassemble with alternating <b> tags
             # logic: even indices are normal, odd are bold
             new_parts = []
             for i, p in enumerate(parts):
                 if i % 2 == 1:
                     new_parts.append(f"<b>{p}</b>")
                 else:
                     new_parts.append(p)
             processed = "".join(new_parts)
             
        # Headers: ### Name -> <b>Name</b>
        if processed.startswith("### "):
            processed = f"<b>{processed[4:].strip()}</b>"
        elif processed.startswith("## "):
            processed = f"<b>{processed[3:].strip()}</b>"
            
        return processed

    # Build the script
    lines = content.split("\n")
    for line in lines:
        raw = line.strip()
        if not raw:
            story.append(Spacer(1, 12)) # Blank line
            continue

        # Logic to guess element type
        # 1. Slugline (INT./EXT.)
        if raw.startswith(("INT.", "EXT.", "INT /", "EXT /", "EST.")) or raw.startswith("SCENE"):
            story.append(Paragraph(format_markdown(raw.upper()), style_slugline))
        
        # 2. Character Cue (All Caps, short, not a slugline, no lowercase unless specific exclusions)
        elif raw.isupper() and len(raw) < 50 and not raw.startswith("("):
            story.append(Paragraph(format_markdown(raw), style_character))

        # 3. Parenthetical
        elif raw.startswith("(") and raw.endswith(")"):
            story.append(Paragraph(format_markdown(raw), style_parenthetical))
        
        # 4. Default to Action/Dialogue (Normal)
        else:
             fmt_line = format_markdown(raw)
             # Bold all-caps lines (except parentheticals)
             if raw.isupper() and len(raw) < 60 and not raw.startswith("("):
                 fmt_line = f"<b>{fmt_line}</b>"
             story.append(Paragraph(fmt_line, style_normal))

    doc.build(story)
    buf.seek(0)
    return buf


# ─── DOCX ─────────────────────────────────────────────────────────────────────

def to_docx(content: str, section: str) -> io.BytesIO:
    """
    Generate a styled DOCX file using python-docx.

    Args:
        content: The generated text for this section.
        section: One of 'screenplay', 'characters', 'sound'.

    Returns:
        BytesIO containing DOCX bytes.
    """
    doc = Document()

    # Title
    title_para = doc.add_heading("CINEMA STUDIO", level=0)
    title_para.runs[0].font.color.rgb = RGBColor(0xC8, 0xA9, 0x6E)

    # Section subtitle
    section_title = SECTION_TITLES.get(section, section.title())
    sub = doc.add_heading(section_title, level=1)
    sub.runs[0].font.color.rgb = RGBColor(0x2C, 0x2C, 0x2C)

    doc.add_paragraph()  # spacer

    # Body — split on newlines, detect headings (lines ending with ':' or all-caps)
    is_screenplay = section == "screenplay"
    for line in content.split("\n"):
        stripped = line.strip()
        if not stripped:
            doc.add_paragraph()
            continue

        # Treat lines that look like scene headings or character headings as sub-headings
        is_heading = (
            stripped.startswith(("INT.", "EXT.", "INT /", "EXT /"))
            or (stripped.isupper() and len(stripped) < 60 and not stripped.startswith("("))
        )

        if is_heading:
            h = doc.add_heading(stripped, level=2)
            for run in h.runs:
                run.font.color.rgb = RGBColor(0x2C, 0x5F, 0x8A)
        else:
            p = doc.add_paragraph(stripped)
            run = p.runs[0] if p.runs else p.add_run(stripped)
            run.font.size = Pt(10)
            if is_screenplay:
                run.font.name = "Courier New"

    buf = io.BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf
